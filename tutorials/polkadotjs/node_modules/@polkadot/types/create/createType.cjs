"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createTypeUnsafe = createTypeUnsafe;
exports.createType = createType;

var _util = require("@polkadot/util");

var _createClass = require("./createClass.cjs");

// Copyright 2017-2021 @polkadot/types authors & contributors
// SPDX-License-Identifier: Apache-2.0
// With isPedantic, actually check that the encoding matches that supplied. This
// is much slower, but verifies that we have the correct types defined
// eslint-disable-next-line @typescript-eslint/ban-types
function checkInstance(value, created) {
  const u8a = created.toU8a();
  const rawType = created.toRawType();
  const isEqual = rawType === 'Bytes' ? value.length === u8a.length : (0, _util.u8aEq)(value, u8a);
  (0, _util.assert)(isEqual, () => `${rawType}:: Decoded input doesn't match input, received ${(0, _util.u8aToHex)(value, 512)} (${value.length} bytes), created ${(0, _util.u8aToHex)(u8a, 512)} (${u8a.length} bytes)`);
} // Initializes a type with a value. This also checks for fallbacks and in the cases
// where isPedantic is specified (storage decoding), also check the format/structure


function initType(registry, Type, params = [], {
  blockHash,
  isPedantic
} = {}) {
  const created = new Type(registry, ...params);
  const value = params[0];

  if (isPedantic) {
    if ((0, _util.isU8a)(value)) {
      checkInstance(value, created);
    } else if ((0, _util.isHex)(value)) {
      checkInstance((0, _util.u8aToU8a)(value.toString()), created);
    }
  }

  if (blockHash) {
    created.createdAtHash = createType(registry, 'Hash', blockHash);
  }

  return created;
} // An unsafe version of the `createType` below. It's unsafe because the `type`
// argument here can be any string, which, when it cannot parse, will yield a
// runtime error.


function createTypeUnsafe(registry, type, params = [], options = {}) {
  try {
    // Circle back to isPedantic when it handles all cases 100% - as of now,
    // it provides false warning which is more hinderance than help
    return initType(registry, (0, _createClass.createClass)(registry, type), params, options);
  } catch (error) {
    throw new Error(`createType(${type}):: ${error.message}`);
  }
}
/**
 * Create an instance of a `type` with a given `params`.
 * @param type - A recognizable string representing the type to create an
 * instance from
 * @param params - The value to instantiate the type with
 */


function createType(registry, type, ...params) {
  return createTypeUnsafe(registry, type, params);
}