// Copyright 2017-2021 @polkadot/types authors & contributors
// SPDX-License-Identifier: Apache-2.0
import { assert, isNumber, isUndefined, stringify } from '@polkadot/util';
import { BTreeMap, BTreeSet, CodecSet, Compact, Enum, HashMap, Int, Option, Result, Struct, Tuple, U8aFixed, UInt, Vec, VecFixed } from "../codec/index.js";
import { DoNotConstruct } from "../primitive/index.js";
import { getTypeDef } from "./getTypeDef.js";
import { TypeDefInfo } from "./types.js";
export function createClass(registry, type) {
  // eslint-disable-next-line @typescript-eslint/no-use-before-define
  return getTypeClass(registry, getTypeDef(type));
} // An unsafe version of the `createType` below. It's unsafe because the `type`
// argument here can be any string, which, if it cannot be parsed, it will yield
// a runtime error.

export function ClassOfUnsafe(registry, name) {
  return createClass(registry, name);
} // alias for createClass

export function ClassOf(registry, name) {
  // TS2589: Type instantiation is excessively deep and possibly infinite.
  // The above happens with as Constructor<InterfaceTypes[K]>;
  // eslint-disable-next-line @typescript-eslint/no-unsafe-return
  return ClassOfUnsafe(registry, name);
}

function getSubDefArray(value) {
  assert(value.sub && Array.isArray(value.sub), () => `Expected subtype as TypeDef[] in ${stringify(value)}`);
  return value.sub;
}

function getSubDef(value) {
  assert(value.sub && !Array.isArray(value.sub), () => `Expected subtype as TypeDef in ${stringify(value)}`);
  return value.sub;
}

function getSubType(value) {
  return getSubDef(value).type;
} // create a maps of type string constructors from the input


function getTypeClassMap(value) {
  const result = {};
  return getSubDefArray(value).reduce((result, sub) => {
    result[sub.name] = sub.type;
    return result;
  }, result);
} // create an array of type string constructors from the input


function getTypeClassArray(value) {
  return getSubDefArray(value).map(({
    type
  }) => type);
}

function createInt({
  displayName,
  length
}, Clazz) {
  assert(isNumber(length), () => `Expected bitLength information for ${displayName || Clazz.constructor.name}<bitLength>`);
  return Clazz.with(length, displayName);
}

function createHashMap(value, Clazz) {
  const [keyType, valueType] = getTypeClassArray(value);
  return Clazz.with(keyType, valueType);
}

const infoMapping = {
  [TypeDefInfo.BTreeMap]: (registry, value) => createHashMap(value, BTreeMap),
  [TypeDefInfo.BTreeSet]: (registry, value) => BTreeSet.with(getSubType(value)),
  [TypeDefInfo.Compact]: (registry, value) => Compact.with(getSubType(value)),
  [TypeDefInfo.DoNotConstruct]: (registry, value) => DoNotConstruct.with(value.displayName),
  [TypeDefInfo.Enum]: (registry, value) => {
    const subs = getSubDefArray(value);
    return Enum.with(subs.every(({
      type
    }) => type === 'Null') ? subs.reduce((out, {
      index,
      name
    }, count) => {
      out[name] = index || count;
      return out;
    }, {}) : getTypeClassMap(value));
  },
  [TypeDefInfo.HashMap]: (registry, value) => createHashMap(value, HashMap),
  [TypeDefInfo.Int]: (registry, value) => createInt(value, Int),
  // We have circular deps between Linkage & Struct
  [TypeDefInfo.Linkage]: (registry, value) => {
    const type = `Option<${getSubType(value)}>`; // eslint-disable-next-line sort-keys

    const Clazz = Struct.with({
      previous: type,
      next: type
    }); // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access

    Clazz.prototype.toRawType = function () {
      // eslint-disable-next-line @typescript-eslint/restrict-template-expressions,@typescript-eslint/no-unsafe-member-access,@typescript-eslint/no-unsafe-call
      return `Linkage<${this.next.toRawType(true)}>`;
    };

    return Clazz;
  },
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  [TypeDefInfo.Null]: (registry, _) => createClass(registry, 'Null'),
  [TypeDefInfo.Option]: (registry, value) => Option.with(getSubType(value)),
  [TypeDefInfo.Plain]: (registry, value) => registry.getOrUnknown(value.type),
  [TypeDefInfo.Result]: (registry, value) => {
    const [Ok, Err] = getTypeClassArray(value); // eslint-disable-next-line @typescript-eslint/no-use-before-define

    return Result.with({
      Err,
      Ok
    });
  },
  [TypeDefInfo.Set]: (registry, value) => {
    const result = {};
    return CodecSet.with(getSubDefArray(value).reduce((result, {
      index,
      name
    }) => {
      result[name] = index;
      return result;
    }, result), value.length);
  },
  [TypeDefInfo.Struct]: (registry, value) => Struct.with(getTypeClassMap(value), value.alias),
  [TypeDefInfo.Tuple]: (registry, value) => Tuple.with(getTypeClassArray(value)),
  [TypeDefInfo.UInt]: (registry, value) => createInt(value, UInt),
  [TypeDefInfo.Vec]: (registry, value) => {
    const subType = getSubType(value);
    return subType === 'u8' ? createClass(registry, 'Bytes') : Vec.with(subType);
  },
  [TypeDefInfo.VecFixed]: (registry, {
    displayName,
    length,
    sub
  }) => {
    assert(isNumber(length) && !isUndefined(sub), 'Expected length & type information for fixed vector');
    return sub.type === 'u8' ? U8aFixed.with(length * 8, displayName) : VecFixed.with(sub.type, length);
  }
}; // Returns the type Class for construction

export function getTypeClass(registry, value) {
  const Type = registry.get(value.type);

  if (Type) {
    return Type;
  }

  const getFn = infoMapping[value.info];
  assert(getFn, () => `Unable to construct class from ${stringify(value)}`);
  return getFn(registry, value);
}