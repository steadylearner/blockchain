// Copyright 2017-2021 @polkadot/api-derive authors & contributors
// SPDX-License-Identifier: Apache-2.0
import { isFunction } from '@polkadot/util';
import { combineLatest, of } from '@polkadot/x-rxjs';
import { catchError, map, switchMap } from '@polkadot/x-rxjs/operators';
import { memo } from "../util/index.js";

function parse(api, [hashes, proposals, votes]) {
  return proposals.map((proposalOpt, index) => proposalOpt && proposalOpt.isSome ? {
    hash: api.registry.createType('Hash', hashes[index]),
    proposal: proposalOpt.unwrap(),
    votes: votes[index].unwrapOr(null)
  } : null).filter(proposal => !!proposal);
}

function _proposalsFrom(instanceId, api, section) {
  return memo(instanceId, hashes => {
    var _api$query$section;

    return (isFunction((_api$query$section = api.query[section]) === null || _api$query$section === void 0 ? void 0 : _api$query$section.proposals) && hashes.length ? combineLatest([of(hashes), combineLatest(hashes.map(hash => // this should simply be api.query[section].proposalOf.multi<Option<Proposal>>(hashes),
    // however we have had cases on Edgeware where the indices have moved around after an
    // upgrade, which results in invalid on-chain data
    api.query[section].proposalOf(hash).pipe(catchError(() => of(null))))), api.query[section].voting.multi(hashes)]) : of([[], [], []])).pipe(map(result => parse(api, result)));
  });
}

export function proposals(instanceId, api, section) {
  const proposalsFrom = _proposalsFrom(instanceId, api, section);

  return memo(instanceId, () => {
    var _api$query$section2;

    return isFunction((_api$query$section2 = api.query[section]) === null || _api$query$section2 === void 0 ? void 0 : _api$query$section2.proposals) ? api.query[section].proposals().pipe(switchMap(proposalsFrom)) : of([]);
  });
}
export function proposal(instanceId, api, section) {
  const proposalsFrom = _proposalsFrom(instanceId, api, section);

  return memo(instanceId, hash => {
    var _api$query$section3;

    return isFunction((_api$query$section3 = api.query[section]) === null || _api$query$section3 === void 0 ? void 0 : _api$query$section3.proposals) ? proposalsFrom([hash]).pipe(map(([proposal]) => proposal)) : of(null);
  });
}